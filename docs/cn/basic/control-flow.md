根据条件是否为真来决定是否执行某些代码, 以及根据条件是否为真来重复运行一段代码是大部分编程语言的基本组成部分.

## `if` Expression

`if` 表达式允许根据条件执行不同的代码分支. 你提供一个条件并表示 "如果条件满足, 运行这段代码；如果条件不满足, 不运行这段代码. "

```rs
let secret = 42;
if secret > 0 {
    > "The secret is positive!";
}
else {
    > "The secret is negative!";
}
```

所有的 `if` 表达式都以 `if` 关键字开头, 其后跟一个条件.

`if` 表达式中与条件关联的代码块有时被叫做 *arms*, .

也可以包含一个可选的 `else` 表达式来提供一个在条件为假时应当执行的代码块, 这里我们就这么做了.

如果不提供 `else` 表达式并且条件为假时, 程序会直接忽略 `if` 代码块并继续执行下面的代码.

另外值得注意的是代码中的条件 **必须** 是 `bool` 值. 如果条件不是 `bool` 值, 我们将得到一个错误. 例如, 尝试运行以下代码:


这个错误表明 Rust 期望一个 `bool` 却得到了一个整数. 不像 Ruby 或 JavaScript 这样的语言, Rust 并不会尝试自动地将非布尔值转换为布尔值. 必须总是显式地使用布尔值作为 `if` 的条件. 例如, 如果想要 `if` 代码块只在一个数字不等于 `0` 时执行, 可以把 `if` 表达式修改成下面这样:


```rs
let number = 3;
if number != 0 {
    println!("number was something other than zero");
}
```

运行代码会打印出 `number was something other than zero`.

## `if else-if` Expression

可以将 `else if` 表达式与 `if` 和 `else` 组合来实现多重条件. 例如:


```valkyrie
let number = 6;
if number % 2 == 0 {
    println!("number is divisible by 2");
}
else if number % 3 == 0 {
    println!("number is divisible by 3");
}
else if number % 4 == 0 {
    println!("number is divisible by 4");
}
else {
    println!("number is not divisible by 2, 3, or 4");
}
```

这个程序有四个可能的执行路径. 运行后应该能看到如下输出:

```text
$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/branches`
number is divisible by 3
```

当执行这个程序时, 它按顺序检查每个 `if` 表达式并执行第一个条件为真的代码块. 注意即使 6 可以被 2 整除, 也不会输出 `number is divisible by 2`, 更不会输出 `else` 块中的 `number is not divisible by 4, 3, or 2`. 原因是 Rust 只会执行第一个条件为真的代码块, 并且一旦它找到一个以后, 甚至都不会检查剩下的条件了.

使用过多的 `else if` 表达式会使代码显得杂乱无章, 所以如果有多于一个 `else if` 表达式, 最好重构代码. 为此, 第六章会介绍一个强大的 Rust 分支结构 (branching construct) , 叫做 `match`.


### 使用循环重复执行

多次执行同一段代码是很常用的, Rust 为此提供了多种 **循环** (*loops*) . 一个循环执行循环体中的代码直到结尾并紧接着回到开头继续执行. 为了实验一下循环, 让我们新建一个叫做 *loops* 的项目.

Rust 有三种循环: `loop`、`while` 和 `for`. 我们每一个都试试.

#### `while` 条件循环

在程序中计算循环的条件也很常见. 当条件为真, 执行循环. 当条件不再为真, 调用 `break` 停止循环. 这个循环类型可以通过组合 `loop`、`if`、`else` 和 `break` 来实现；如果你喜欢的话, 现在就可以在程序中试试.

然而, 这个模式太常用了, Rust 为此内置了一个语言结构, 它被称为 `while` 循环. 示例 3-3 使用了 `while`: 程序循环三次, 每次数字都减一. 接着, 在循环结束后, 打印出另一个信息并退出.

<span class="filename">文件名: src/main.rs</span>

```valkyrie
fn main() {
    let mut number = 3;

    while number != 0 {
        println!("{}!", number);

        number = number - 1;
    }

    println!("LIFTOFF!!!");
}
```

<span class="caption">示例 3-3: 当条件为真时, 使用 `while` 循环运行代码</span>

这种结构消除了很多使用 `loop`、`if`、`else` 和 `break` 时所必须的嵌套, 这样更加清晰. 当条件为真就执行, 否则退出循环.


#### 从循环返回

`loop` 的一个用例是重试可能会失败的操作, 比如检查线程是否完成了任务. 然而你可能会需要将操作的结果传递给其它的代码. 如果将返回值加入你用来停止循环的 `break` 表达式, 它会被停止的循环返回:

```valkyrie
fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!("The result is {}", result);
}
```

在循环之前, 我们声明了一个名为 `counter` 的变量并初始化为 `0`. 接着声明了一个名为 `result` 来存放循环的返回值. 在循环的每一次迭代中, 我们将 `counter` 变量加 `1`, 接着检查计数是否等于 `10`. 当相等时, 使用 `break` 关键字返回值 `counter * 2`. 循环之后, 我们通过分号结束赋值给 `result` 的语句. 最后打印出 `result` 的值, 也就是 20.


## `for` Expression
可以使用 `for` 循环来对一个集合的每个元素执行一些代码. `for` 循环看起来如示例 3-5 所示:

<span class="filename">文件名: src/main.rs</span>

```valkyrie
fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a.iter() {
        println!("the value is: {}", element);
    }
}
```

<span class="caption">示例 3-5: 使用 `for` 循环遍历集合中的元素</span>

当运行这段代码时, 将看到与示例 3-4 一样的输出. 更为重要的是, 我们增强了代码安全性, 并消除了可能由于超出数组的结尾或遍历长度不够而缺少一些元素而导致的 bug.

例如, 在示例 3-4 的代码中, 如果从数组 `a` 中移除一个元素但忘记将条件更新为 `while index < 4`, 代码将会 panic. 使用 `for` 循环的话, 就不需要惦记着在改变数组元素个数时修改其他的代码了.

`for` 循环的安全性和简洁性使得它成为 Rust 中使用最多的循环结构. 即使是在想要循环执行代码特定次数时, 例如示例 3-3 中使用 `while` 循环的倒计时例子, 大部分 Rustacean 也会使用 `for` 循环. 这么做的方式是使用 `Range`, 它是标准库提供的类型, 用来生成从一个数字开始到另一个数字之前结束的所有数字的序列.

下面是一个使用 `for` 循环来倒计时的例子, 它还使用了一个我们还未讲到的方法, `rev`, 用来反转 range:

<span class="filename">文件名: src/main.rs</span>

```valkyrie
fn main() {
    for number in (1..4).rev() {
        println!("{}!", number);
    }
    println!("LIFTOFF!!!");
}
```

这段代码看起来更帅气不是吗？
