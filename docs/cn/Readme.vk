# Valkyrie Language


## è®¾è®¡ç›®æ ‡

Valkyrie æ˜¯ä¸€é—¨å…·æœ‰æ¸è¿›ç±»å‹çš„åŠ¨æ€è¯­è¨€,

Valkyrie çš„è®¾è®¡ç›®æ ‡æ˜¯çµæ´», ç®€æ´ä»¥åŠé«˜åº¦çš„ä¸€è‡´æ€§

å…¶è¡€ç¼˜æ¥è‡ª Rust, Scala ä»¥åŠ Swift.

æ¥ä¸‹æ¥ä»‹ç» Valkyrie çš„ä¸»è¦ç‰¹æ€§

## æ‰©å±•

å¦‚æœæ²¡æœ‰æ‰©å±•, é‚£ä¹ˆ V æ˜¯ä¸€é—¨å¾ˆæ­»æ¿å¾ˆä¸¥æ ¼çš„è¯­è¨€.

ä¸¥æ ¼çš„ä»¤äººéš¾å—, `1 + 1.0`, `"a" + 'b'`, `[1] ++ 2`, ç»Ÿç»Ÿç®—ä¸äº†.

æ‰©å±•èµ‹äºˆäº† V é«˜åº¦çš„çµæ´»æ€§ä¸å¯èƒ½æ€§.

é»˜è®¤ä¼šè½½å…¥åä¸º Prelude çš„æ‰©å±•, Prelude ä¸­å®šä¹‰äº†ä¸€äº›å¸¸ç”¨çš„åˆç†çš„è¿ç®—è§„åˆ™.

extension å¯ä»¥ç»§æ‰¿å’Œé‡å†™, ä½ å¯ä»¥ä¹Ÿå®šä¹‰è‡ªå·±çš„ Prelude, ç„¶åå½¢æˆè‡ªå·±çš„ä»£ç é£æ ¼.

V ä¸­æ‰€æœ‰çš„è¯­æ³•ç³–éƒ½ç”±å¯¹åº”çš„ trait æ¥é™æ€å†³ç­–, ä»¥æ­¤æ¥å…é™¤ä¸å¿…è¦è¿è¡Œæ—¶å¼€é”€

### å­¤å„¿è§„åˆ™

å¦‚æœä½ æƒ³æ‰©å±•ä¸€ä¸ªæ–¹æ³•, è¦ä¹ˆç±»æ˜¯åœ¨ä½ çš„åº“ä¸­å®šä¹‰çš„, è¦ä¹ˆç‰¹è´¨æ˜¯åœ¨ä½ çš„åº“ä¸­å®šä¹‰çš„

å¦åˆ™åªèƒ½åœ¨ extension package namespace ä¸­ä¿®æ”¹

è¿™ä¸€è§„åˆ™æ˜¯ä¸ºäº†é˜²æ­¢åœ¨ä¸çŸ¥æƒ…çš„æƒ…å†µä¸‹å¼•å…¥æœªçŸ¥çš„è¯­ä¹‰

````valkyrie
/// Namespace is generally lowercase, but extension is uppercase
/// Because the performance is similar to the introduce a trait
pkg extension Features;
````

### ç¬¦å·é‡è½½

æœ€å¸¸è§çš„åº”ç”¨æ˜¯ç¬¦å·é‡è½½, å½“ä½ è¦æ•´åˆä¸¤ä¸ªç¬¬ä¸‰æ–¹åº“ç±»å‹è½¬æ¢æ—¶, ç»å¸¸ä¼šè¢«å­¤å„¿è§„åˆ™ç¦æ­¢.

å› æ­¤éœ€è¦å£°æ˜ extension æ¥å®ç°å…¼å®¹.

è¿˜æœ‰ä¸€ç§æƒ…å†µæ˜¯æŸä¸ªè¿ç®—æ˜¯æ–¹ä¾¿çš„, ä½†å¯èƒ½ä¸æ˜¯å¾ˆä¸¥æ ¼.

æ¯”å¦‚æˆ‘ä»¬ä¸€èˆ¬é»˜è®¤åŠ æ³•æœä»äº¤æ¢å¾‹, ä½†æ˜¯ `"a" + "b" != "b" + "a"` ç ´åäº†äº¤æ¢å¾‹.

äºæ˜¯å¯ä»¥å°†é€‰æ‹©æƒäº¤ç»™åº“ç”¨æˆ·.

````valkyrie
/// Otherwise, all it will inherit all extensions in the current namespace
@no_prelude
pkg extension FreeAdd {
    /// Symbols are defined in the standard library
    /// Types are also defined in the standard library
    /// Overloading is prohibited by the orphan rule
    /// Ordinary overload does not need extension
    def +(i: Integer, f: Decimal) {
        /// The function will return automatically
        /// The return type is automatically inferred
        i as Decimal + f
    }
}
````

### æ•°å­—æ¨¡å¼

æœ‰æ—¶å€™æˆ‘ä»¬æƒ³è¾“å…¥ä¸€äº›ç‰¹æ®Šçš„æ•°å€¼, æ¯”å¦‚å¸¦å•ä½çš„è¿ç®—, å¦‚æœç”¨æ„é€ å™¨å¾ˆå¯èƒ½è®©ä»£ç å¤±å»å¯è¯»æ€§.

è¿™ç§æƒ…å†µä¸‹å¯ä»¥ç”¨æ•°å­—æ¨¡å¼, æ•°å­—æ¨¡å¼æ˜¯åç¼€å½¢å¼çš„.

````valkyrie
tagged Quality {
    Kilogram(auto Decimal),
    Gram(auto Decimal),
}
def +(lhs: Quality, rhg: Quality): Quality {
    /// Some conversion rules, that's it, anyone can write
    @unimplemented()
}

pkg extension SIUnit {
    /// number_suffix means integer_suffix + decimal_suffix
    def number_suffix kg(n): Quality = Quality::Kilogram(n);
    def number_suffix  g(n): Quality = Quality::Gram(n);
}
````

ç„¶åä½ å°±å¯ä»¥å†™å¦‚ä¸‹å†™æ³•äº†!

````valkyrie
use SIUnit;
let weight = 1kg + 1g;
````

ä»¥æ­¤ç±»æ¨, ä½ åº”è¯¥èƒ½å¾ˆè½»æ˜“çš„å®ç°ä¸‹åˆ—åŠŸèƒ½, è¿™å°±æ˜¯ Valkyrie ä¸€è‡´æ€§çš„ä½“ç°.

````valkyrie
use Complex;
let z = 1 + 2i;
/// Note that you cannot bind `i` twice in one namespace
use Quaternion;
let q = 1 + 2i + 3j + 4k;
````

### å­—ç¬¦ä¸²æ¨¡å¼

å­—ç¬¦ä¸²ä¹Ÿæ˜¯ä¸ªå¾ˆå¤æ‚çš„ä¸œè¥¿, ä¼—å£éš¾è°ƒ, ä¸åŒçš„äººå–œæ¬¢ä¸åŒçš„å†™æ³•

å¥½åœ¨æˆ‘ä»¬æœ‰å­—ç¬¦ä¸²æ¨¡å¼, å­—ç¬¦ä¸²æ¨¡å¼æ˜¯å‰ç¼€è¡¨è¾¾.

å¦‚æœä»€ä¹ˆå‰ç¼€ä¹Ÿæ²¡æœ‰, é»˜è®¤çš„å­—ç¬¦ä¸²å« s-string(slot).

````valkyrie
r"raw-string:    ${x + 1}\n"
s"slot-string:   ${x + 1}\n"
f"format-string: %s %f\s \n"
````

åŒæ ·çš„, ä½ ä¹Ÿå¯ä»¥ç”¨ `extension` æ‰©å±•ä½ è‡ªå·±çš„å­—ç¬¦ä¸²æ¨¡å¼.

ä½ å·²ç»çŒœåˆ°äº†, ä½¿ç”¨ `string_prefix`, è¿™ä¹Ÿæ˜¯ä¸€è‡´æ€§çš„ä½“ç°.

ä½ èƒ½æƒ³åˆ°ä»€ä¹ˆåº”ç”¨? åµŒå…¥ json å¯¹è±¡? åµŒå…¥ css æ ·å¼? æˆ–è€…æ›´ç‚«é…·çš„ç”¨æ³•?


## æ¨¡å¼åŒ¹é…

è¶Šæ¥è¶Šå¤šçš„è¯­è¨€é‡‡ç”¨æ¨¡å¼åŒ¹é…æˆ–è€…ç±»ä¼¼çš„è¯­æ³•, æ¨¡å¼åŒ¹é…å¿«æˆæ¯ä¸ªè¯­è¨€çš„æ ‡é…äº†.

V å½“ç„¶ä¹Ÿæœ‰ä¸ªé«˜åº¦ä¸€è‡´, å¯ desugar çš„çµæ´»æ¨¡å¼åŒ¹é…è¯­æ³•

### å­—é¢é‡åŒ¹é…

å­—é¢é‡åŒ¹é…æ˜¯æ ‡é…

````valkyrie
match x {
    case 1      => "integer"
    case 1.0    => "decimal"
    case '1'    => "character"
    case "1"    => "string"
    case 1...4  => "range"
    case (1, 2) => "tuple"
    case [1, 2] => "list"
    _           => "something else"
}
````

### case å®ˆå«

æœ‰æ—¶å€™æ¨¡å¼åŒ¹é…é‡éœ€è¦ä¸€ç‚¹æ¡ä»¶åˆ¤å®š, è¿™ç§æƒ…å†µä¸‹å¯ä»¥ç”¨ case å®ˆå«

````valkyrie
match x {
    case x is Integer   => "x is an instance of type `Integer`"
    case x is Callablte => "x satisfies the trait bound `Callable`"
    case x in [1, 2, 3] => "x is one of [1, 2, 3]"
    case x if x < 0     => "x satisfies the condition x < 0"
    _                   => "none of the above conditions are met"
}
````

### case è§£æ„

æŸäº›æ—¶å€™æƒ³è¦åŒ¹é…æŸä¸€æ®µæ•°æ®, é‚£ä¹ˆå¯ä»¥ç”¨ case è§£æ„

````valkyrie
if case Point {x: a, y, ...p} = Point {x: 1, y: 2, z: 3, w: 4,} {
    print(a) /// 1
    print(y) /// 2
    print(p) /// {z: 3, w: 4}
}

if case Point(a, ..p, y) = Point(1, 2, 3, 4) {
    print(a) /// 1
    print(p) /// [2, 3]
    print(y) /// 4
}
````

### è‡ªå®šä¹‰æå–å™¨

å¯¹äºè‡ªå®šä¹‰çš„ç±», å¯ä»¥å®šä¹‰ unapply æ–¹æ³•æ¥è‡ªå®šä¹‰æå–çš„æ•°æ®.


````valkyrie
match input {
    case Regex(group0) => Integer::parse(group0),
}
/// desugar as unapply
if case Some(group0) = Regex::unapply(input) {
    Integer::parse(group0)
}
````


## é—­åŒ…å’ŒåŒ¿åå‡½æ•°

é—­åŒ…ä¹Ÿæ˜¯ä¸€ä¸ªç°ä»£åŒ–çš„è¯­è¨€å¿…å¤‡çš„ç‰¹æ€§

è€ƒè™‘å¦‚ä¸‹å‡½æ•°

````valkyrie
def doulbe_even(x) {
    match x {
        x if x % 2 => 2 * x,
        x          => x
    }
}
[1, 2, 3, 4].map(doulbe_even)
````

å¦‚æœä¸€ä¸ªå‡½æ•°æ¥å—çš„æœ€åä¸€ä¸ªå‚æ•°æ˜¯é—­åŒ…, é‚£ä¹ˆå¯ä»¥çœç•¥ `()`

ç°åœ¨è€ƒè™‘æŠŠå®ƒå†™æˆåŒ¿åå‡½æ•°

````valkyrie
[1, 2, 3, 4].map {
    /// `(lambda (x) expr)` even longer than python ğŸ¤£
    lambda (x) match x {
        x if x % 2 => 2 * x,
        x          => x
    }
}
````

è¿™ä¸ªçœ‹èµ·æ¥ä¹Ÿå¤ªå¤æ‚äº†, è¿™æ˜¯å®Œå…¨å½¢å¼çš„é—­åŒ…, åªæ˜¯ä½œä¸º desugar çš„ç»“æœè€Œå­˜åœ¨, å®é™…ç”¨ä¸åˆ°

ä¸€èˆ¬å¸¸ç”¨çš„æ˜¯ä¸‹é¢çš„ case é—­åŒ…:

````valkyrie
[1, 2, 3, 4].map {
    case x if x % 2 => 2 * x,
    case x          => x
}
````

è¿˜æœ‰ä¸€ç§ç®€å†™æ–¹å¼å« slot é—­åŒ…:

````valkyrie
[1, 2, 3, 4].map {
    if $0 % 2 {2 * $0} else {$0}
}
/// Looks like perl, maybe the ternary operator should be banned
[1, 2, 3, 4].map {$0 % 2 ? 2 * $0 : $0}
````


## å¤šæ€

æœ‰æ—¶å€™æˆ‘ä»¬éœ€è¦ä¸€äº›å¤šæ€æ¥å£, æ¯”å¦‚åŒæ—¶æ¥å—å­—ç¬¦ä¸²å’Œæ•´æ•°çš„å‡½æ•°

ä¾µå…¥æ€§æœ€å¼ºä½†æ˜¯ç”¨èµ·æ¥æœ€æ–¹ä¾¿çš„æ˜¯éšå¼ç±»å‹è½¬æ¢

````valkyrie
/// First define ordinary type conversion
extends Integer: From<String> {
    def from(s) { Self::parse(i) }
}
/// `ImplicitFrom<T>` needs to meet trait bound `From<T>`
extends Integer: ImplicitFrom<String>;

def add_one(input: Integer): Integer {
    input + 1
}
/// Found type mismatch, try implicit type conversion
add_one("1") /// 2
````

å…¶æ¬¡æ˜¯æ˜¾å¼ç±»å‹è½¬æ¢, è‡ªåŠ¨è§„çº¦è¾“å…¥

````valkyrie
def add_one(auto input: Integer): Integer {
    input + 1
}
/// Found that the type does not match, call the `from` method
add_one("1") /// 2
````

æ¯”è¾ƒè§„èŒƒçš„æ˜¯ä½¿ç”¨åŸºäº trait çš„æ³›å‹é™æ€æ´¾å‘

````valkyrie
def add_one<T>(input: T): Integer
for T: Into<Integer>
{
    input.into() + 1
}
````

ä»¥ä¸Šè¿™äº›æ–¹æ³•éƒ½æ˜¯éé™å®šæ€§çš„å¤šæ€, è¾“å…¥ä¸éœ€è¦é¢„å…ˆç¡®å®š.

ä½†æ˜¯æœ‰æ—¶å€™è¾“å…¥æ˜¯å›ºå®šçš„å‡ ç±», è¿™å°±éœ€è¦é™å®šæ€§å¤šæ€.

é™å®šæ€§å¤šæ€å¯ä»¥ç”¨å¹¶ç±»å‹å’Œå’Œç±»å‹å®ç°, å¾ˆå¤šè¯­è¨€é‡Œä¸åŒºåˆ†è¿™ä¸¤ä¸ª, ç”šè‡³æ··æ·†äº†ä¸¤è€….

ä½†æ˜¯ä»”ç»†æƒ³æƒ³ `Optional<Optional<T>>` å’Œ `Nullable<Nullable<T>>` èƒ½ä¸€æ ·å—?

````valkyrie
/// This is the sum type, tagged union
tagged Optional<T> {
    Some<T>,
    None,
}

/// This is the union type, untagged union
class Null {};
type Nullable<T> = T | Null;

Optional<Optional<T>> ==> Optional<Optional<T>>
Nullable<Nullable<T>> ==> Nullable<T>
````

````valkyrie
/// sum type matching
def add_one(input: Integer|String): Integer {
    let y = match input {
        x is Integer => x,
        x is String => Integer::parse(x)
    }
    y + 1
}

/// union type matching
tagged Canbe {
    Integer(Integer)
    String(String)
}

def add_one(input: Canbe): Integer {
    let y = match input {
        Canbe::Integer(x) => x,
        Canbe::String(x) => Integer::parse(x)
    }
    y + 1
}
````

## ä¸“é—¨è®¾è®¡çš„ REPL æ¨¡å¼

REPL æ¨¡å¼æ˜¯æŒ‡ç±»ä¼¼äº Mathematica, Observable æˆ–è€… Jupyter çš„å·¥ä½œæ¨¡å¼

### æ—¶åºä¸éæ—¶åºæ¨¡å¼

è€ƒè™‘å¦‚ä¸‹ä»£ç :

````valkyrie
let second  = 1 + first;
let first  = 1;
````

åœ¨å¸¦æ—¶åºçš„è¯­è¨€ä¸­, è¿™åº”è¯¥ç›´æ¥æŠ¥é”™, ç¬¬ä¸€è¡Œå…ˆäºç¬¬äºŒè¡Œå‘ç”Ÿ, ä¸èƒ½ä½¿ç”¨ä¸€ä¸ªæœªå£°æ˜æœªåˆå§‹åŒ–çš„å˜é‡ `first`.

ä½†æ˜¯åœ¨æ— æ—¶åºçš„è¯­è¨€ä¸­, è¿™æ˜¯å¯ä»¥å®ç°çš„, å› ä¸ºæ‰€æœ‰å£°æ˜éƒ½åœ¨åŒä¸€æ—¶åˆ»å‘ç”Ÿ, æ²¡æœ‰è°å…ˆè°å.

å†è€ƒè™‘å¦‚ä¸‹ä»£ç :

````valkyrie
let a = 1;
let a = 2;
````

åœ¨å¸¦æ—¶åºçš„è¯­è¨€ä¸­, æ˜¾ç„¶ç¬¬äºŒæ¬¡è¡Œåº”è¯¥è¦†ç›–ç¬¬ä¸€è¡Œå…³äº `a` çš„å£°æ˜.

ä½†æ˜¯åœ¨æ— æ—¶åºçš„è¯­è¨€ä¸­ä¼šæŠ¥é”™, å› ä¸ºæ‰€æœ‰å£°æ˜éƒ½åœ¨åŒä¸€æ—¶åˆ»å‘ç”Ÿ, æ²¡æœ‰è°å…ˆè°å.

Valkyrie ä¸­çš„ä½œç”¨åŸŸå’Œé—­åŒ…æ˜¯æœ‰æ—¶åºçš„, ä½†æ˜¯ä¹Ÿä¸èƒ½é‡å¤å£°æ˜å‡½æ•°

è€Œå…¶ä»–çš„ package, class, trait, tagged éƒ½æ˜¯æ— æ—¶åºçš„, å› æ­¤ç¦æ­¢é‡å¤å£°æ˜

### REPL æ¨¡å¼

ä½†æ˜¯åœ¨ REPL æ¨¡å¼ä¸‹, package namespace æ˜¯æ—¶åºçš„, å¯ä»¥åå¤ä¿®æ”¹ä¸€ä¸ªå‡½æ•°å¹¶è¦†ç›–æ‰ä¹‹å‰è¿™æ ·å¾ˆæ–¹ä¾¿è°ƒè¯•.

REPL æ¨¡å¼ä¸‹æ‰€æœ‰æœªå£°æ˜çš„å˜é‡é»˜è®¤æ˜¯é¦–æ¬¡å£°æ˜çš„å¯å˜å˜é‡, è¿™ç§è®¾å®šå€Ÿé‰´äº† Mathematica, ä¹Ÿå¾ˆæ–¹ä¾¿è°ƒè¯•

REPL æ¨¡å¼ä¸‹å¯ä»¥ä½¿ç”¨ `use?` å¯¼å…¥ä¸€ä¸ªå¤–éƒ¨æ¨¡å—å¹¶å…è®¸åå¤å¯¼å…¥, ä»¥æ­¤å®ç°çƒ­é‡è½½

è¿™é‡Œ `?` è¡¨ç¤ºä¸è¦åŠ å…¥å…¨å±€æ–¹æ³•è¡¨, å› ä¸ºä¸€æ—¦åŠ å…¥å°±ä¼šæ±¡æŸ“æ‰€æœ‰çš„å®šä¹‰, è¿™ç§æ±¡æŸ“æ˜¯ä¸å¯é€†çš„.

REPL æ¨¡å¼å¯ä»¥ä½¿ç”¨ `Â¶` å’Œ `â‹` è·å–å†å²è¾“å…¥è¾“å‡º, ç›¸å½“äº Mathematica çš„ `In`, `Out` ä»¥åŠ `%`

## åŸºäº AST çš„å®

åŸºäº AST çš„å®å¯èƒ½æ²¡æœ‰åŸºäº Token çš„å®é‚£ä¹ˆå¼ºå¤§, ä½†æ˜¯ä½ çœŸçš„æƒ³åœ¨ä¸€ä¸ªè¯­è¨€é‡Œå†™å®Œå…¨ä¸åŒçš„å¦ä¸€ä¸ªè¯­è¨€å—?

ç‰¹åˆ«æ˜¯ Token å®çš„ IDE æ”¯æŒæ€§ä¸€èˆ¬ç‰¹åˆ«å·®, å¸¦ TokenKind çš„ AST å®å´èƒ½è·å¾—éå¸¸å¥½çš„æ”¯æŒ.

## IR å…¼å®¹æ€§

Valkyrie çš„è¯­æ³•å¹¶ä¸æ˜¯ç»å¯¹ç¨³å®šçš„, Valkyrie ä¼šæŠŠæºæ–‡ä»¶ç¼–è¯‘æˆå•ä¸ªçš„ IR æ–‡ä»¶æ¥å±è”½è¿™ç§æ”¹å˜, ç”±æ­¤æ¥è·å¾—å‰å‘å…¼å®¹æ€§.

Valkyrie ä½¿ç”¨ç±»ä¼¼ Rust çš„ Edition å‘å¸ƒæ¨¡å¼.
